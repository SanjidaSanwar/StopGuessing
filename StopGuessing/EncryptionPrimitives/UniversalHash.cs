using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace StopGuessing.EncryptionPrimitives
{

    /// <summary>
    /// A keyed universal hash function is a function that produces up to 32-bits that meet the definition of
    /// a universal hash (and an additional 32 bits that do not meet the requirement and so, in theory
    /// could be biased), guaranteeing that:
    ///   (1) an attacker cannot construct inputs that are likely to have a bias of 0/1 at any bit position
    ///   (2) an attacker cannot construct two values that will collide with a greater-than-random chance
    /// so long as that attacker
    ///   (a) does not know the key, and
    ///   (b) is unable to observe the outputs of the function.
    /// 
    /// In contrast, standard hash functions do not guarantee that attackers cannot easily generate collisions,
    /// / even if the application using the function prefixes or postfixes the value to be hashed with a key.
    /// This leaves systems that use standard (non-universal) hash functions vulnerable to algorithmic complexity
    /// attacks.  See:
    ///     https://www.usenix.org/legacy/events/sec03/tech/full_papers/crosby/crosby.pdf
    /// 
    /// When generating a hash, the lower 32 bits generated by the function should be thrown out unless you are certain
    /// that using bits that may be subject to attacker bias will cause no harm.  For example, for a hash ring that uses
    /// all 64-bit points, where the first 32 are the universal hash bits, collisions should be strictly less likely than in a 
    /// ring that only uses the 32 safe bits---though your ring entries will require twice as much space.)
    /// 
    /// An instance of a universal hash function is re-entrant so, once an instance has been constructed, the hash function
    /// can be safely called from multiple threads to perform more than one hash at a time.
    /// 
    /// For more information on the construction used in this implementation, see 
    ///     https://en.wikipedia.org/wiki/Universal_hashing
    ///     (this construction is the last one in the "hashing vectors" section, labled with the superscript "strong")
    /// and
    ///     http://comjnl.oxfordjournals.org/content/57/11/1624.full.pdf
    ///     (this is the simple "Multilinear" construction)  
    /// </summary>
    public class UniversalHashFunction
    {
        private readonly ulong _initialRandomKey;
        private readonly ulong[] _randomKeyVector;
        private int _randomKeyVectorLengthInBytes;

        /// <summary>
        /// This function generates 64 bits and, if fewer bits are requested, returns the leftmost bits.
        /// Only the first (high-order) 32 bits meet the requirements for a universal hash.
        /// The lower 32 bits generated by the function should be thrown out except in applications
        /// where the additional bits will do no harm.  (For example, a hash table that uses all 64 bits,
        /// where the first 32 are the universal hash bits, should be strictly less likely to have a collision
        /// than one that uses only the first 32 safe bits.)
        /// </summary>
        public const int MaximumNumberOfResultBitsGuaranteedToBeUnbiased = 32;

        public const int MaximumNumberOfResultBitsAllowing32BiasedBits = 64;


        private void SetVectorLength(int randomKeyVectorLengthInBytes)
        {
            // We must allocate at least 16 bytes so we can be sure to be able to hash
            // values up to 64-bit numbers.
            if (randomKeyVectorLengthInBytes < 16)
                randomKeyVectorLengthInBytes = 16;

            // Ensure the RandomKeyVectorLengthInBytes falls on a 32-bit boundary
            int mod8;
            if ((mod8 = randomKeyVectorLengthInBytes % 8) != 0)
            {
                // MaxLengthInBytes is not divisible by 4 bytes.
                // Round up so that we Get a 32-bit boundary.
                randomKeyVectorLengthInBytes += (8 - mod8);
            }
            _randomKeyVectorLengthInBytes = randomKeyVectorLengthInBytes;
        }


        /// <summary>
        /// Construct a random universal hash function
        /// </summary>
        /// <param name="randomKeyVectorLengthInBytes">The length of the random key vector used for hashing.  Should be twice the length of the longest value you expect to hash,
        /// unless you hash values bigger than you would want to keep in memory.  If hashing a value longer than this, the universal hash properties may not hold.</param>
        public UniversalHashFunction(int randomKeyVectorLengthInBytes)
        {
            int numberOfPseudoRandomBytesNeeded = SetVectorLengthAndGetNumberOfRandomBytesNeeded(randomKeyVectorLengthInBytes);
            byte[] pseudoRandomBytes = new byte[numberOfPseudoRandomBytesNeeded];

            StrongRandomNumberGenerator.GetBytes(pseudoRandomBytes);

            // Create the random key vector and fill it with random bytes
            _randomKeyVector = new ulong[randomKeyVectorLengthInBytes/8];
            for (int i = 0; i < _randomKeyVector.Length; i++)
                _randomKeyVector[i] = BitConverter.ToUInt64(pseudoRandomBytes, i*8);
            // Fill the initial random key with the last remaining 8 bytes
            _initialRandomKey = BitConverter.ToUInt64(pseudoRandomBytes, randomKeyVectorLengthInBytes);
        }



        /// <summary>
        /// Construct a keyed universal hash function.
        /// 
        /// An instance of a universal hash function needs to store on the order of RandomKeyVectorLengthInBytes values upon construction,
        /// so it is best not to initialize this function for large strings (e.g., those over 32k).
        /// 
        /// </summary>
        /// <param name="keyOf16Or24Or32Bytes">A key that should not be known to those who might try to create collisions, provided as an array of 16, 24, or 32 bytes.</param>
        /// <param name="randomKeyVectorLengthInBytes">The length of the random key vector used for hashing.  Should be twice the length of the longest value you expect to hash,
        /// unless you hash values bigger than you would want to keep in memory.  If hashing a value longer than this, the universal hash properties may not hold.</param>
        public UniversalHashFunction(byte[] keyOf16Or24Or32Bytes, int randomKeyVectorLengthInBytes = 256)
        {
            int numberOfRandomBytesToGenerate = SetVectorLengthAndGetNumberOfRandomBytesNeeded(randomKeyVectorLengthInBytes);

            // Generate enough random bytes to fill the RandomKeyVector and 4 extra for the InitialRandomKey
            using (System.Security.Cryptography.Aes aes = System.Security.Cryptography.Aes.Create())
            {
                aes.Key = keyOf16Or24Or32Bytes;
                aes.IV = new byte[16];
                aes.Mode = System.Security.Cryptography.CipherMode.CBC;

                // Encrypt a null message with the key using CBC and InitializationVector=0
                byte[] pseudoRandomBytes;
                using (System.IO.MemoryStream ciphertext = new System.IO.MemoryStream())
                {
                    using (System.Security.Cryptography.CryptoStream cs = new System.Security.Cryptography.CryptoStream(ciphertext, aes.CreateEncryptor(), System.Security.Cryptography.CryptoStreamMode.Write))
                    {
                        if (numberOfRandomBytesToGenerate % 16 != 0)
                        {
                            // Round to next 128-bit boundary since we're using AES 128-bit blocks to generate randomness
                            numberOfRandomBytesToGenerate += 16 - (numberOfRandomBytesToGenerate % 16);
                        }
                        cs.Write(new byte[numberOfRandomBytesToGenerate], 0, numberOfRandomBytesToGenerate);
                        // Ensure all bytes are flushed.
                    }
                    pseudoRandomBytes = ciphertext.ToArray();
                }

                // Create the random key vector and fill it with random bytes
                _randomKeyVector = new ulong[randomKeyVectorLengthInBytes / 8];
                for (int i = 0; i < _randomKeyVector.Length; i++)
                    _randomKeyVector[i] = BitConverter.ToUInt64(pseudoRandomBytes, i * 8);
                // Fill the initial random key with the last remaining 8 bytes
                _initialRandomKey = BitConverter.ToUInt64(pseudoRandomBytes, randomKeyVectorLengthInBytes);
            }
        }

        
        /// <param name="key">A key that should not be known to those who might try to create collisions, provided as a string.</param>
        /// <param name="randomKeyVectorLengthInBytes">The number of random bytes to generate, which should be equal
        /// to half the maximum allowable length, in bytes, of any value to be hashed.</param>
        public UniversalHashFunction(string key, int randomKeyVectorLengthInBytes = 256)
            : this(ManagedSHA256.Hash(Encoding.UTF8.GetBytes(key)), randomKeyVectorLengthInBytes)
        {
        }


        /// <summary>
        /// Hash an array of 32 bit values.
        /// </summary>
        /// <param name="messageToBeHashed">An array of 32 bit unsigned values.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits).</returns>
        public ulong Hash(IList<UInt32> messageToBeHashed, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            if (messageToBeHashed.Count > _randomKeyVector.Length)
                return HashArrayThatExceedsLengthOfRandomKeyVector(messageToBeHashed, numberOfBitsToReturn);
            ulong sum = _initialRandomKey;
            for (int i = 0; i < messageToBeHashed.Count; i++) {
                sum += messageToBeHashed[i] * _randomKeyVector[i];
            }
            return sum >> (64 - numberOfBitsToReturn);
        }


        private int SetVectorLengthAndGetNumberOfRandomBytesNeeded(int randomKeyVectorLengthInBytes)
        {
            SetVectorLength(randomKeyVectorLengthInBytes);
            // We must allocate at least 16 bytes so we can be sure to be able to hash
            // values up to 64-bit numbers.
            if (randomKeyVectorLengthInBytes < 16)
                randomKeyVectorLengthInBytes = 16;

            // Ensure the RandomKeyVectorLengthInBytes falls on a 32-bit boundary
            int mod8;
            if ((mod8 = randomKeyVectorLengthInBytes % 8) != 0)
            {
                // MaxLengthInBytes is not divisible by 4 bytes.
                // Round up so that we Get a 32-bit boundary.
                randomKeyVectorLengthInBytes += (8 - mod8);
            }
            _randomKeyVectorLengthInBytes = randomKeyVectorLengthInBytes;

            // The number of random bytes we need is equal to the length of the 
            // random key vector + 8 bytes for the InitialRandomKey.
            return 8 + _randomKeyVectorLengthInBytes;
        }

        /// <summary>
        /// Hash an array of bytes.
        /// </summary>
        /// <param name="messageToBeHashed">An array of bytes.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits).</returns>
        public ulong Hash(IList<byte> messageToBeHashed, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            if (messageToBeHashed.Count > (_randomKeyVector.Length * 4))
                return HashArrayThatExceedsLengthOfRandomKeyVector(messageToBeHashed, numberOfBitsToReturn);
            ulong sum = _initialRandomKey;
            int indexIntoRandomKeyVector = 0;
            for (int i = 0; i < messageToBeHashed.Count; i++)
            {
                // Construct uint32 to Step to hash from four bytes
                // (or leave zeros where bytes are missing)
                ulong value = (((UInt32)messageToBeHashed[i]) << 24);
                if (++i < messageToBeHashed.Count)
                    value |= (((UInt32)messageToBeHashed[i]) << 16);
                if (++i < messageToBeHashed.Count)
                    value |= (((UInt32)messageToBeHashed[i]) << 8);
                if (++i < messageToBeHashed.Count)
                    value |= messageToBeHashed[i];

                value *= _randomKeyVector[indexIntoRandomKeyVector++];
                sum += value;
            }
            return sum >> (64 - numberOfBitsToReturn);
        }

        /// <summary>
        /// When asked to hash a value that exceeds the length of the key vector, we break the
        /// message into blocks no larger than the hash of the key vector, hash each block,
        /// and then recursively hash the array containing the hash of each block.
        /// (If the message is so long that the array of block hashes exceeds the length
        ///  of the key vector, we'll do so again yet again.)
        /// </summary>
        /// <param name="messageToBeHashed">The message to be hashed as an array</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        internal ulong HashArrayThatExceedsLengthOfRandomKeyVector(IList<UInt32> messageToBeHashed, int numberOfBitsToReturn)
        {
            // Use this data structure to store the hashes recusively obtained by calling the hash function on each block
            List<UInt32> hashesForEachBlock = new List<uint>(2 + 2 * (messageToBeHashed.Count / _randomKeyVector.Length));

            // Recursively hash each block to create an array of 32-bit hashes
            int valuesConsumed = messageToBeHashed.Count;
            while (valuesConsumed < messageToBeHashed.Count)
            {
                List<UInt32> block = messageToBeHashed.Skip(valuesConsumed).Take(_randomKeyVector.Length).ToList();
                ulong blockHash = Hash(block);
                hashesForEachBlock.Add((UInt32)(blockHash >> 32));
                hashesForEachBlock.Add((UInt32)(blockHash & 0xFFFFFFFF));
                valuesConsumed += block.Count;
            }

            // Resurively call the hash function on the 32-bit array of block hashes and return the result
            return Hash(hashesForEachBlock, numberOfBitsToReturn);
        }


        internal ulong HashArrayThatExceedsLengthOfRandomKeyVector(IList<byte> messageToBeHashed, int numberOfBitsToReturn)
        {
            // Use this data structure to store the hashes recusively obtained by calling the hash function on each block
            List<UInt32> hashesForEachBlock = new List<uint>(2 + 2 * (messageToBeHashed.Count / (_randomKeyVectorLengthInBytes)));

            // Recursively hash each block of RandomKeyVectorLengthInBytes bytes to create an array of 32-bit hashes
            int valuesConsumed = messageToBeHashed.Count;
            while (valuesConsumed < messageToBeHashed.Count)
            {
                List<byte> block = messageToBeHashed.Skip(valuesConsumed).Take(_randomKeyVectorLengthInBytes).ToList();
                ulong blockHash = Hash(block);
                hashesForEachBlock.Add((UInt32)(blockHash >> 32));
                hashesForEachBlock.Add((UInt32)(blockHash & 0xFFFFFFFF));
                valuesConsumed += block.Count;
            }

            // Resurively call the hash function on the 32-bit array of block hashes and return the result
            return Hash(hashesForEachBlock, numberOfBitsToReturn);
        }


        /// <summary>
        /// Hash a string.
        /// </summary>
        /// <param name="stringToHash">A string to hash, which will be converted to a UTF8 byte array for hashing.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        public ulong Hash(string stringToHash, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased) {
            return Hash(Encoding.UTF8.GetBytes(stringToHash), numberOfBitsToReturn);
        }

        /// <summary>
        /// Hash a value.
        /// </summary>
        /// <param name="valueToHash">The value to be hashed.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        public ulong Hash(UInt32 valueToHash, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            ulong hashValue = _initialRandomKey + (valueToHash * _randomKeyVector[0]);
            return hashValue >> (64 - numberOfBitsToReturn);
        }

        /// <summary>
        /// Hash a value.
        /// </summary>
        /// <param name="valueToHash">The value to be hashed.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        public ulong Hash(Int32 valueToHash, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            ulong hashValue = _initialRandomKey + (((ulong)valueToHash) * _randomKeyVector[0]);
            return hashValue >> (64 - numberOfBitsToReturn);
        }

        /// <summary>
        /// Hash a value.
        /// </summary>
        /// <param name="valueToHash">The value to be hashed.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        public ulong Hash(ulong valueToHash, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            ulong hashValue = _initialRandomKey +
                ((valueToHash >> 32) * _randomKeyVector[0]) +
                ((valueToHash & 0xFFFFFFFF) * _randomKeyVector[1]);
            return hashValue >> (64 - numberOfBitsToReturn);
        }

        /// <summary>
        /// Hash a value.
        /// </summary>
        /// <param name="valueToHash">The value to be hashed.</param>
        /// <param name="numberOfBitsToReturn">The number of hash bits to return.
        /// Use a value ≤ 32 to ensure the result meets the requirements of a unviversal hash.
        /// If you choose a value between 33 and 64, only the high-order 32 bits are guaranteed to be unbiased.</param>
        /// <returns>An unsigned hash of <paramref name="numberOfBitsToReturn"/> bits.</returns>
        public ulong Hash(Int64 valueToHash, int numberOfBitsToReturn = MaximumNumberOfResultBitsGuaranteedToBeUnbiased)
        {
            ulong hashValue = _initialRandomKey +
                (((ulong)valueToHash >> 32) * _randomKeyVector[0]) +
                (((ulong)valueToHash & 0xFFFFFFFF) * _randomKeyVector[1]);
            return hashValue >> (64 - numberOfBitsToReturn);
        }


    }

}
